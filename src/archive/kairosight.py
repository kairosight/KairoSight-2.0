#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import sys
from pathlib import Path
import traceback
import numpy as np
import pandas as pd
from pathlib import PurePath

import scipy.signal as sig
from PyQt5 import QtCore, QtWidgets
from PyQt5.QtCore import QDir, Qt
from PyQt5.QtGui import QStandardItemModel
from PyQt5.QtWidgets import QApplication, QWidget, QMainWindow, QFileDialog, QFileSystemModel, QDialogButtonBox, \
    QTableWidgetItem, QLabel, QComboBox, QCheckBox
import pyqtgraph as pg
from archive.ui.KairoSightMainMDI import Ui_MDIMainWindow
from ui.KairoSightWidgetTIFFpyqtgraph import Ui_WidgetTiff
from ui.KairoSightWidgetFolderTree import Ui_WidgetFolderTree
from ui.KairoSightWidgetSplit import Ui_WidgetSplit
from ui.KairoSightWidgetIsolate import Ui_WidgetIsolate
from ui.KairoSightWidgetAnalyze import Ui_WidgetAnalyze
from ui.KairoSightWidgetExport import Ui_WidgetExport
from ui.signalwidget import SignalWidget
from algorithms import tifopen, align, peak_detect, process


class MDIWindow(QMainWindow, Ui_MDIMainWindow):
    """Customization for Ui_MDIMainWindow, and MDI main window"""

    def __init__(self, parent=None):
        # initialization of the superclass
        super(MDIWindow, self).__init__(parent)
        # setup the GUI --> function generated by pyuic5
        self.setupUi(self)
        # connect the signals with the slots
        # self.actionLoad.triggered.connect(self.open_tiff)
        # self.actionClose.triggered.connect(self.close)
        self.actionTIFF.triggered.connect(self.open_tiff)
        self.actionFolder.triggered.connect(self.open_folder)
        self.actionStart_Isolate.triggered.connect(self.isolate)
        self.actionStart_Analyze.triggered.connect(self.analyze)
        self.menuExport.aboutToShow.connect(self.export)

    def open_tiff(self, file=None):
        """Open a SubWindow with a TIFF stack in the main MDI area"""
        if file:
            print('Opening tiff with passed filepath: ' + file)
        else:
            # Use a QFileDialog to get filepath if none provided
            file, mask = QFileDialog.getOpenFileName(self, 'Open a .tif/.tiff stack')

        if file:
            self.status_print('Opening ' + file + ' ...')
            f_purepath = PurePath(file)
            f_prefix = str(f_purepath.parent) + '\\'
            f_dir = f_purepath.parent.parts[-1]
            f_name = f_purepath.stem
            f_ext = f_purepath.suffix
            f_display = f_prefix + '\t' + f_name + ' ' + f_ext
            print('file (path name ext): ' + f_display)
            try:
                if f_ext == '.pcoraw':
                    # Change .pcoraw files to .tif?
                    # os.rename(file, f_name + '.tif')
                    p = Path(file)
                    p.rename(p.with_suffix('.tif'))
                    print('* .pcoraw covnerted to a .tif')
                    # Use a QFileDialog to get the new filepath
                    file, mask = QFileDialog.getOpenFileName(self, 'Open a .tif/.tiff stack')
                    self.status_print('Opening ' + file + ' ...')
                    f_purepath = PurePath(file)
                    f_prefix = str(f_purepath.parent) + '\\'
                    f_dir = f_purepath.parent.parts[-1]
                    f_name = f_purepath.stem
                    f_ext = f_purepath.suffix
                    f_display = f_prefix + '\t' + f_name + ' ' + f_ext
                    print('file (path name ext): ' + f_display)
                # Create QMdiSubWindow with Ui_WidgetTiff
                sub = WindowTiff(parent=self, f_prefix=f_prefix, f_dir=f_dir, f_name=f_name, f_ext=f_ext)
                sub.setObjectName(str(file))
                sub.setWindowTitle('TIFF View: ' + f_display)
                # Add and connect QMdiSubWindow to MDI
                self.mdiArea.addSubWindow(sub)
                # print('"sub" added to MDI')
                sub.show()
                self.statusBar().showMessage('Opened ' + file)
            except Exception:
                exctype, exvalue = sys.exc_info()[:2]
                self.MainWindow.status_print('FAILED to open, ' + str(exctype) + ' : ' + str(exvalue))
                traceback.print_exc()
        else:
            print('path is None')
            self.statusBar().showMessage('Open cancelled')

    def open_folder(self):
        """Open a SubWindow with a folder tree view in the main MDI area"""
        folder_path = QFileDialog.getExistingDirectory(self, 'Choose a folder to view')
        print('Folder chosen! path: ' + folder_path)
        # Create QMdiSubWindow with Ui_WidgetTiff
        sub = WindowFolder(parent=self, root=folder_path)
        print('WindowFolder "sub" created')
        print('Set "sub" widget to "Ui_WidgetFolderTree"')
        sub.setWindowTitle('Folder View: ' + folder_path)
        # Add and connect QMdiSubWindow to MDI
        self.mdiArea.addSubWindow(sub)
        sub.pushButtonOpen.released.connect(lambda: self.open_tiff(sub.currentFilePath))
        print('"sub" added to MDI')
        sub.show()

    def isolate(self):
        """Open the Isolate SubWindow"""
        tiff_windows = []
        # Create a list of all open TIFF subwindows
        for sub in self.mdiArea.subWindowList():
            # print('**' + str(type(sub.widget())) + ', ' + sub.widget().objectName() + ' is a tiff? ')
            if type(sub.widget()) is WindowTiff:
                tiff_windows.append(sub)
        if tiff_windows:
            sub_iso = WindowIsolate(parent=self, w_list=tiff_windows)
            self.mdiArea.addSubWindow(sub_iso)
            sub_iso.show()
        else:
            self.statusBar().showMessage('No processed videos to isolate!')

    def analyze(self):
        """Open the Analyze SubWindow"""
        tiff_windows = []
        # Create a list of all open TIFF subwindows
        for sub in self.mdiArea.subWindowList():
            # print('**' + str(type(sub.widget())) + ', ' + sub.widget().objectName() + ' is a tiff? ')
            if type(sub.widget()) is WindowTiff:
                if sub.widget().ROIs:
                    tiff_windows.append(sub)
        if tiff_windows:
            sub_analyze = WindowAnalyze(parent=self, w_list=tiff_windows)
            self.mdiArea.addSubWindow(sub_analyze)
            sub_analyze.show()
        else:
            self.statusBar().showMessage('No processed videos with ROIs to analyze!')

    def export(self):
        """Open a dialog to copy or export .csv of Analysis results"""
        tiff_windows = []
        # Create a list of all open TIFF subwindows
        for sub in self.mdiArea.subWindowList():
            # print('**' + str(type(sub.widget())) + ', ' + sub.widget().objectName() + ' is a tiff? ')
            if type(sub.widget()) is WindowTiff:
                # if sub.widget().ROIs:
                tiff_windows.append(sub)
        if tiff_windows:
            sub_export = WindowExport(w_list=tiff_windows)
            self.mdiArea.addSubWindow(sub_export)
            sub_export.show()
        else:
            self.statusBar().showMessage('No analyzed ROIs with results to export!')

    def status_print(self, text):
        self.statusBar().showMessage(text)


class WindowTiff(QWidget, Ui_WidgetTiff):
    """Customization for Ui_WidgetTiff subwindow for an MDI"""
    # TODO build a better data tree for ROIs and Analysis
    INDEX_R, TYPE_R, POSITION, SIZE = range(4)
    INDEX_A, ROI, TYPE_A, ROI_CALC, FRAMES, FILTER, DETREND, PEAKS = range(8)

    def __init__(self, parent=None, f_prefix=None, f_dir=None, f_name=None, f_ext=None):
        # Initialization of the superclass
        super(WindowTiff, self).__init__(parent)
        self.MainWindow = parent
        # Setup the GUI
        self.setupUi(self)
        pg.setConfigOptions(background=pg.mkColor(0.1))
        pg.setConfigOptions(foreground=pg.mkColor(0.3))
        # Preserve plot area's aspect ration so image always scales correctly
        self.graphicsView.p1.setAspectLocked(True)
        # Connect the scrollbar's value signal to trigger a video update
        self.horizontalScrollBar.valueChanged['int'].connect(self.updateVideo)

        # Load the video file
        self.video_prefix = f_prefix
        self.video_dir = f_dir
        self.video_name = f_name
        self.video_ext = f_ext
        print('* Opening video:', self.video_dir, ' / ', self.video_name, ' ', self.video_ext)
        self.video_file, self.dt = tifopen.tifopen(self.video_prefix, self.video_name + self.video_ext)
        # print('tifopen finished')
        # get video properties
        self.video_shape = self.video_file.shape
        if len(self.video_shape) < 3:
            raise Exception('TIFF has less than 3 dimensions')
        self.frames = self.video_shape[0]

        # Transpose second and third axes (y, x) to correct orientation (x, y)
        print('* Transposing')
        self.video_data = np.transpose(self.video_file, (2, 1, 0))
        # Flip each frame in the left/right direction, expected to be up/down
        print('* Flipping each frame along x-axis')
        for i in range(self.frames):
            self.video_data[..., i] = np.fliplr(self.video_data[..., i])

        # Add an axis to the video data array, in case of video splitting, (x, y, time, signal)
        self.video_data = self.video_data[..., np.newaxis]
        # Create array of display data
        self.display_data = self.video_data[..., 0]
        self.video_shape = self.video_data.shape
        self.frames = self.video_shape[2]

        # Use a dummy dt (aka Frame Period) if none detected
        # From most MetaMorph videos: exposure time 1.219 ms -> dt = 1.238 ms
        if np.isnan(self.dt):
            self.framePeriodMsLabel.setText('?Frame Period (ms)')
            self.frameRateLabel.setText('?Frame Rate (fps)')
            self.dt = 1.238

        # Limit all float results to 5 significant digits, due to dt limit
        self.dt = float("{0:.5g}".format(self.dt))

        # Set-up Properties fields
        self.subject = self.video_dir  # e.g. 20190418-ratb
        self.fps = 1000 / self.dt
        self.duration = self.dt * self.frames
        self.width, self.height = self.video_shape[0], self.video_shape[1]
        self.resolution = None  # cm/px
        print('video shape:         ', self.video_shape)
        print('Width x Height:      ', self.width, self.height)
        print('# of Frames:         ', self.frames)
        print('Frame Period (ms):   ', self.dt)
        print('FPS:                 ', self.fps)
        print('Duration (ms):       ', self.duration)

        self.SizeLabelEdit.setText(str(self.width) + ' X ' + str(self.height)
                                   + ' [ X ' + str(self.frames) + ']')

        self.subjectLineEdit.setText(self.subject)
        self.framePeriodMsLineEdit.setText(str(self.dt))
        self.frameRateLineEdit.setText(str(self.fps))
        self.durationMsLineEdit.setText(str(self.duration))
        self.durationMsLineEdit.setEnabled(False)

        self.subjectLineEdit.editingFinished.connect(lambda: self.updateProperties(param=self.subject))
        self.framePeriodMsLineEdit.editingFinished.connect(lambda: self.updateProperties(param=self.dt))
        self.frameRateLineEdit.editingFinished.connect(lambda: self.updateProperties(param=self.fps))
        self.resolutionLineEdit.editingFinished.connect(lambda: self.updateProperties(param=self.resolution))
        self.updateProperties()

        # Setup Signals data and Signals UI for splitting options
        self.Signal_widgets = []
        self.SIGNAL_OPTIONS = ['Voltage (Vm)', 'Calcium (Ca)']
        self.SIGNAL_COLORS = ['w', 'r', 'g']
        self.SIGNAL_ALPHAS = [0, 127, 255]
        self.pushButtonSignalAdd.pressed.connect(self.splitVideo)
        self.pushButtonSignalRemove.pressed.connect(self.reduceVideo)
        # Add a default signal
        self.addSignal()

        # Setup ROIs and Anlysis data
        self.ROIs = []  # A list of pg.ROI objects
        self.ROIsLabels = []  # A list of pg.ROI object labels
        self.Analysis = []  # A list of Analysis results dictionaries
        self.analysis_default = {'ROI': '0', 'INDEX_A': np.nan, 'TYPE': 'Voltage',
                                 'ROI_CALC': 'Mean', 'FRAMES': '1-XXXX', 'FILTER': '75', 'DETREND': '2',
                                 'PEAKS': '0.72,172', 'RESULTS': None}
        # Set scroll bar maximum to number of frames
        self.horizontalScrollBar.setMinimum(1)
        self.horizontalScrollBar.setMaximum(self.frames)
        self.frame_current = 0
        # Set histogram to image levels and use a manual range
        self.graphicsView.histograms[0].setLevels(self.display_data.min(), self.display_data.max())
        self.graphicsView.histograms[0].setHistogramRange(self.display_data.min(), self.display_data.max())

        # Setup data treeviews
        # Calling it a treeview, currently connected to table-like models
        # ROI model
        self.treeViewROIs.setAlternatingRowColors(True)
        self.modelRoi = QStandardItemModel(0, 4)
        self.modelRoi.setHeaderData(self.INDEX_R, Qt.Horizontal, "#")
        self.modelRoi.setHeaderData(self.TYPE_R, Qt.Horizontal, "Type")
        self.modelRoi.setHeaderData(self.POSITION, Qt.Horizontal, "Position (X,Y)")
        self.modelRoi.setHeaderData(self.SIZE, Qt.Horizontal, "Size (px)")
        self.treeViewROIs.setModel(self.modelRoi)
        for idx in range(4):
            self.treeViewROIs.resizeColumnToContents(idx)

        # Analysis model
        self.treeViewAnalysis.setAlternatingRowColors(True)
        self.modelAnalysis = QStandardItemModel(0, 7)
        self.modelAnalysis.setHeaderData(self.INDEX_A, Qt.Horizontal, "#")
        self.modelAnalysis.setHeaderData(self.ROI, Qt.Horizontal, "ROI#")
        self.modelAnalysis.setHeaderData(self.TYPE_A, Qt.Horizontal, "Type")
        self.modelAnalysis.setHeaderData(self.ROI_CALC, Qt.Horizontal, "ROI Calc.")
        self.modelAnalysis.setHeaderData(self.FRAMES, Qt.Horizontal, "Frames")
        self.modelAnalysis.setHeaderData(self.FILTER, Qt.Horizontal, "Filter")
        self.modelAnalysis.setHeaderData(self.PEAKS, Qt.Horizontal, "Peak Det.")
        self.treeViewAnalysis.setModel(self.modelAnalysis)
        for idx in range(7):
            self.treeViewAnalysis.resizeColumnToContents(idx)
        print('WidgetTiff ready')

    def updateProperties(self, param=None):
        """Update TIFF parameters with user-entered/calculated values

            Parameters
            ----------
            param : str, optional
                If specified, the particular parameter changed
            """
        # TODO Invalidate old analysis results when these change?
        print('*** Updating properties')
        # Get text-based params
        self.subject = self.subjectLineEdit.text()
        self.resolution = self.resolutionLineEdit.text()
        # Populate all 'new' params by default
        dt_new = float(self.framePeriodMsLineEdit.text())
        fps_new = float(self.frameRateLineEdit.text())
        # Either use new dt or new fps to calculate the other
        if param is self.dt:
            dt_new = float(self.framePeriodMsLineEdit.text())
            fps_new = 1000 / dt_new
        elif param is self.fps:
            fps_new = float(self.frameRateLineEdit.text())
            dt_new = 1000 / fps_new
        duration_new = dt_new * self.frames

        # Limit Frame Period and Frame Rate to 5 significant figures
        self.dt = float("{0:.5g}".format(dt_new))
        self.fps = float("{0:.5g}".format(fps_new))
        self.duration = float("{0:.5g}".format(duration_new))

        # Update Properties UI elements
        self.framePeriodMsLineEdit.setText(str(self.dt))
        self.frameRateLineEdit.setText(str(self.fps))
        self.durationMsLineEdit.setText(str(self.duration))
        # self.signals = []
        print('** Updated properties')

    def updateVideo(self, frame=0):
        """Updates the video frame drawn to the canvas"""
        # print('Updating video plot in a subWindow with:')
        # print('\n*** Showing ' + self.video_name + '[' + str(frame) + ']')

        # Update ImageItem(s) with a frame in a stack
        try:

            # self.graphicsView.p1.clear()
            self.frame_current = frame
            self.display_data = self.video_data[..., 0]
            self.video_shape = self.video_data.shape
            self.width, self.height = self.video_shape[0], self.video_shape[1]
            for idx, stack in enumerate(self.graphicsView.stacks):
                stack.setImage(self.video_data[..., frame - 1, idx])
            # self.graphicsView.stacks[0].setImage(self.display_data[frame - 1])
            # Notify histogram items of image change
            for hist in self.graphicsView.histograms:
                hist.regionChanged()
        except Exception:
            traceback.print_exc()

        # Draw ROIs
        # if self.ROIs:
        #     for roi in self.ROIs:
        #         self.graphicsView.p1.addItem(roi)

    def addSignal(self):
        """Adds UI elements corresponding to a new Signal"""
        print('\n*** Adding a Signal')
        idx_new = self.formLayoutSignals.rowCount()
        # idx_new = len(self.signal_ComboBoxes)
        label_new = str(idx_new + 1)
        print('** Signal #' + label_new)
        # self.formLayoutSignals.addRow(QLabel("#" + label_new), QComboBox())
        # self.signal1ComboBox.addItems(self.SIGNAL_OPTIONS)
        print('* Create a SignalWidget')
        signal_widget_new = SignalWidget(self)
        signal_widget_new.comboBoxSignal.addItems(self.SIGNAL_OPTIONS)
        print('* Add the SignalWidget to the form (with label)')
        self.formLayoutSignals.addRow(QLabel(label_new), signal_widget_new)
        signal_widget_new.comboBoxSignal.currentIndexChanged['int'].connect(self.updateProperties)
        signal_widget_new.checkBoxSignal.stateChanged.connect(lambda: self.toggleSignal(signal_w=signal_widget_new))
        self.Signal_widgets.append(signal_widget_new)

        if idx_new > 0:
            try:
                print('* Add the new HistogramLUTItem')
                hist_new = pg.HistogramLUTItem()
                # Item for displaying image data
                img = pg.ImageItem()
                self.graphicsView.p1.addItem(img)
                self.graphicsView.stacks.append(img)

                hist_new.setImageItem(img)
                hist_new.vb.setMouseEnabled(y=False)  # makes user interaction a little easier
                self.graphicsView.widget.addItem(hist_new)
                self.graphicsView.histograms.append(hist_new)

                for idx, hist in enumerate(self.graphicsView.histograms):
                    # Set histogram to image levels and use a manual range
                    hist.setLevels(self.video_data[..., idx].min(), self.video_data[..., idx].max())
                    hist.setHistogramRange(self.video_data[..., idx].min(), self.video_data[..., idx].max())
                    # Set top (last) tick color of each histogram
                    hist.gradient.setTickColor(1, pg.mkColor(self.SIGNAL_COLORS[idx+1]))
                    hist.gradientChanged()
            except Exception:
                traceback.print_exc()

            for signal in self.Signal_widgets:
                # Set each signal opacity (alpha) to ~50%
                signal.alpha = self.SIGNAL_ALPHAS[1]
                self.toggleSignal(signal_w=signal)

        self.pushButtonSignalAdd.setEnabled(True)
        print('** Signals are now: ' + str(self.Signal_widgets))

    def toggleSignal(self, signal_w=None):
        """Toggles visibility of a particular signal stack

        Parameters
        ----------
        signal_w : SignalWidget
            A custom Widget representing each signal"""
        # print('*** Toggling Signal # XXX')
        try:
            idx_sig = self.Signal_widgets.index(signal_w)
            his = self.graphicsView.histograms[idx_sig]
            print('*** Toggling Signal #' + str(idx_sig + 1))
            ticks = his.gradient.ticks
            for idx_tick, tick in enumerate(ticks):
                color_old = tick.color
                color_oldRGB = [color_old.red(), color_old.green(), color_old.blue()]
                if signal_w.checkBoxSignal.isChecked():
                    print('* Turning on')
                    print('* Changing tick alphas back to original value')
                    color_new = color_oldRGB[0], color_oldRGB[1], color_oldRGB[2], signal_w.alpha
                else:
                    print('* Turning off')
                    print('* Changing tick alphas to 0')
                    color_new = color_oldRGB[0], color_oldRGB[1], color_oldRGB[2], 0
                his.gradient.setTickColor(idx_tick, pg.mkColor(color_new))
                his.gradientChanged()
        except Exception:
            traceback.print_exc()

    def splitVideo(self):
        """Splits and aligns a multi-signal video"""
        print('\n*** Splitting current video data')
        try:
            sub_split = WindowSplit(parent=self)
            # main_window = self.MainWindow
            self.MainWindow.mdiArea.addSubWindow(sub_split)
            sub_split.show()
            self.pushButtonSignalAdd.setEnabled(False)
        except Exception:
            traceback.print_exc()

    def reduceVideo(self):
        """Reduce the number of signals/videos after splitting"""
        print('\n*** Reducing video')
        # idx_remove = len(self.signal_ComboBoxes)
        # print('** Removing Signal #' + idx_remove)
        # self.formLayoutSignals.removeRow(idx_remove)

    def getRoiPreview(self, roi):
        data_img = self.graphicsView.stacks[0]
        data = self.display_data[..., self.frame_current]
        data_preview = roi.getArrayRegion(data, data_img)
        return data_preview

    def getRoiStack(self, roi, stack_idx=0, start_idx=None, end_idx=None):
        data_stack = []
        # for idx, frame in enumerate(self.display_data):
        current_display_data = self.video_data[..., stack_idx]
        for i in range(current_display_data.shape[-1]):
            data_img = self.graphicsView.stacks[stack_idx]
            data_roi_frame = roi.getArrayRegion(current_display_data[..., i], data_img)
            data_roi_frame[data_roi_frame == 0] = np.nan
            data_stack.append(data_roi_frame)
        if (start_idx or end_idx) is not None:
            if not start_idx:
                return data_stack[:end_idx]
            if not end_idx:
                return data_stack[start_idx:]
            return data_stack[start_idx:end_idx]
        else:
            return data_stack

    def addROI(self, idx=None, roi=None):
        print('\n*** addROI: idx:', idx, ' roi:', roi)
        if roi:
            print('* ROIs were: ', self.ROIs)
            roi.translatable = False
            roi_state = roi.getState()
            x, y = str(int(roi_state['pos'].x())), str(int(roi_state['pos'].y()))
            position = x + ',' + y
            r = int(roi_state['size'][0])

            if idx is not None:
                roi_current = self.ROIs[idx]
                label_current = self.ROIsLabels[idx]
                print('** Changing existing ROI from: ', roi_current)
                print('**                              to: ', roi)
                roi_current.setState(roi_state)
                roi_current.setPen(color='54FF00')
                label_current.setPos(int(x), int(y))
            else:
                print('** Adding passed ROI: ', roi)
                length = self.modelRoi.rowCount()
                idx = length
                self.modelRoi.insertRow(idx)
                roi_new = pg.CircleROI([x, y], [r, r], pen=(2, 9), movable=False)
                roi_new.setPen(color='54FF00')
                self.graphicsView.p1.addItem(roi_new)
                self.ROIs.append(roi_new)
                roi_new.removeHandle(0)
                label = pg.TextItem('#' + str(idx))
                label.setPos(int(x), int(y))
                label.setColor(color='54FF00')
                self.graphicsView.p1.addItem(label)
                self.ROIsLabels.append(label)

            self.modelRoi.setData(self.modelRoi.index(idx, self.INDEX_R), idx)
            self.modelRoi.setData(self.modelRoi.index(idx, self.TYPE_R), 'Circle')
            self.modelRoi.setData(self.modelRoi.index(idx, self.POSITION), position)
            self.modelRoi.setData(self.modelRoi.index(idx, self.SIZE), r)
            for idx in range(4):
                self.treeViewROIs.resizeColumnToContents(idx)
            # print('* ROIs are now: ', self.ROIs)
        else:
            print('** No ROI to add!')

    def removeROI(self, idx=None, roi=None):
        if roi:
            try:
                print('** Removing passed ROI: ', roi)
                rois_new = [j for i, j in enumerate(self.ROIs) if i not in [idx]]
                self.modelRoi.removeRow(idx)
                self.graphicsView.p1.removeItem(roi)
                self.ROIs = rois_new

                labels_new = [j for i, j in enumerate(self.ROIsLabels) if i not in [idx]]
                self.graphicsView.p1.removeItem(self.ROIsLabels[idx])
                self.ROIsLabels = labels_new
                for idx in range(4):
                    self.treeViewROIs.resizeColumnToContents(idx)
            except Exception:
                traceback.print_exc()
        else:
            print('** No ROI to remove!')

    def addAnalysis(self, idx=None, analysis=None):
        if analysis:
            print('\n*** addAnalysis: idx:', idx, ' analysis:', analysis)
            roi = analysis['ROI']
            analysis_type = analysis['TYPE']
            roi_calc = analysis['ROI_CALC']
            frames = analysis['FRAMES']
            analysis_filter = analysis['FILTER']
            analysis_detrend = analysis['DETREND']
            peaks = analysis['PEAKS']
            if idx is not None:
                analysis_current = self.Analysis[idx]
                print('** Changing existing Analysis from: ', analysis_current)
                print('**                              to: ', analysis)
                analysis['INDEX_A'] = idx
                self.Analysis[idx] = analysis.copy()
            else:
                print('** Adding passed Analysis: ')
                length = self.modelAnalysis.rowCount()
                idx = length
                analysis['INDEX_A'] = idx
                self.Analysis.append(analysis.copy())
                self.modelAnalysis.insertRow(idx)

            self.modelAnalysis.setData(self.modelAnalysis.index(idx, self.INDEX_A), str(idx))
            self.modelAnalysis.setData(self.modelAnalysis.index(idx, self.ROI), roi)
            self.modelAnalysis.setData(self.modelAnalysis.index(idx, self.TYPE_A), analysis_type)
            self.modelAnalysis.setData(self.modelAnalysis.index(idx, self.ROI_CALC), roi_calc)
            self.modelAnalysis.setData(self.modelAnalysis.index(idx, self.FRAMES), frames)
            self.modelAnalysis.setData(self.modelAnalysis.index(idx, self.FILTER), analysis_filter)
            self.modelAnalysis.setData(self.modelAnalysis.index(idx, self.DETREND), analysis_detrend)
            self.modelAnalysis.setData(self.modelAnalysis.index(idx, self.PEAKS), peaks)
            for idx in range(8):
                self.treeViewAnalysis.resizeColumnToContents(idx)
        else:
            print('** No Analysis to add!')

    def removeAnalysis(self, idx=None, analysis=None):
        if analysis:
            print('* Removing passed Analysis: ', analysis)
            analysis_new = [j for i, j in enumerate(self.Analysis) if i not in [idx]]
            self.Analysis = analysis_new
            self.modelAnalysis.removeRow(idx)
            for idx in range(8):
                self.treeViewAnalysis.resizeColumnToContents(idx)
        else:
            print('* No Analysis to remove!')


class WindowFolder(QWidget, Ui_WidgetFolderTree):
    """Customization for Ui_WidgetFolderTree subwindow for an MDI"""

    def __init__(self, parent=None, root=None):
        # initialization of the superclass
        super(WindowFolder, self).__init__(parent)
        self.dir = QDir(root)
        self.currentFileName = ''
        self.currentFilePath = ''
        # setup the GUI
        self.setupUi(self)
        print('WidgetFolderTree UI setup')
        self.model = QFileSystemModel()
        self.model.setRootPath(root)
        self.treeView.setModel(self.model)
        self.treeView.setRootIndex(self.model.index(root))
        print('treeView ready')

    @QtCore.pyqtSlot(QtCore.QModelIndex)
    def on_treeView_clicked(self, index):
        index_item = self.model.index(index.row(), 0, index.parent())
        self.currentFileName = self.model.fileName(index_item)
        self.currentFilePath = self.model.filePath(index_item)
        print('Clicked: ' + self.currentFilePath + ' ' + self.currentFileName)


class WindowSplit(QWidget, Ui_WidgetSplit):
    """Customization for Ui_WidgetSplit subwindow for an MDI"""

    def __init__(self, parent=None):
        # initialization of the superclass
        super(WindowSplit, self).__init__(parent)
        self.MainWindow = parent

        print('Creating WidgetSplit')
        self.currentWindow = parent
        self.currentPlot = self.currentWindow.graphicsView.p1
        self.image_full = self.currentWindow.display_data
        # Create preview ROIs
        # TODO Create ROIs with no scale handles
        self.roi_A = pg.RectROI([0, 0], [0, 0])
        self.roi_A.setPen(color='54FF00')
        self.roi_B = pg.RectROI([0, 0], [0, 0])
        self.roi_B.setPen(color='FF000A')
        self.currentPlot.addItem(self.roi_A)
        self.currentPlot.addItem(self.roi_B)

        print('WidgetSplit UI setup...')
        self.setupUi(self)
        try:
            self.lockDimensionsCheckBox.stateChanged.connect(self.updateParameters)

            self.originXSpinBoxSignalA.valueChanged.connect(self.updateParameters)
            self.originYSpinBoxSignalA.valueChanged.connect(self.updateParameters)
            self.heightSpinBoxSignalA.valueChanged.connect(self.updateParameters)
            self.heightSpinBoxSignalA.valueChanged.connect(self.updateParameters)

            self.originXSpinBoxSignalB.valueChanged.connect(self.updateParameters)
            self.originYSpinBoxSignalB.valueChanged.connect(self.updateParameters)
            self.heightSpinBoxSignalB.valueChanged.connect(self.updateParameters)
            self.heightSpinBoxSignalB.valueChanged.connect(self.updateParameters)

            # self.roi_A.sigRegionChanged.connect(self.updatePreviewImage)
            # self.roi_A.sigRegionChangeFinished.connect(lambda: self.updateParameters(self.roi_preview))
            self.roi_A.sigRegionChangeStarted.connect(lambda: self.readROIs(roi=self.roi_A))
            self.roi_B.sigRegionChangeStarted.connect(lambda: self.readROIs(roi=self.roi_B))

            self.lockDimensionsCheckBox.stateChanged.connect(self.updateParameters)
            self.buttonBox.button(QDialogButtonBox.RestoreDefaults).clicked.connect(self.loadDefaults)
            self.buttonBox.button(QDialogButtonBox.Apply).clicked.connect(self.applySplit)
            self.loadDefaults()
        except:
            exctype, exvalue = sys.exc_info()[:2]
            self.MainWindow.status_print('FAILED WidgetSplit setup, ' + str(exctype) + ' : ' + str(exvalue))
            traceback.print_exc()

        print('WidgetSplit ready')

    def closeEvent(self, event):
        """Reimplementation of QWidget.closeEvent

        Parameters
        ----------
        event : PySide2.QtGui.QCloseEvent
            Event when Qt receives a window close request for a top-level widget from the window system
        """
        # for roi in self.currentWindow.ROIs:
        #     roi.setPen(color='54FF00')
        # self.checkBoxPreview.setChecked(False)

        # Remove preview ROIs

        self.currentPlot.removeItem(self.roi_A)
        self.currentPlot.removeItem(self.roi_B)
        self.currentWindow.pushButtonSignalAdd.setEnabled(True)
        self.destroy(destroyWindow=True)
        event.accept()

    def loadDefaults(self):
        """Populate Split parameter inputs with default values"""
        print('** Loading defaults')
        w, h = int(self.currentWindow.width / 2), int(self.currentWindow.height)
        w_A, h_A = w, h
        x_A, y_A = 0, 0
        x_B, y_B = w_A + (w - w_A), y_A
        # Populate fields with default values
        self.originXSpinBoxSignalA.setValue(x_A)
        self.originYSpinBoxSignalA.setValue(y_A)
        self.widthSpinBoxSignalA.setValue(w_A)
        self.heightSpinBoxSignalA.setValue(h_A)

        self.originXSpinBoxSignalB.setValue(x_B)
        self.originYSpinBoxSignalB.setValue(y_B)

        self.lockDimensionsCheckBox.setChecked(True)
        self.updateParameters()

    def readROIs(self, roi):
        print('** Reading a ROI state')
        roi_state = roi.getState()
        x, y = str(int(roi_state['pos'].x())), str(int(roi_state['pos'].y()))
        w, h = int(roi_state['size'])
        if roi is self.roi_A:
            # Populate fields with roi's new values
            self.originXSpinBoxSignalA.setValue(x)
            self.originYSpinBoxSignalA.setValue(y)
            self.widthSpinBoxSignalA.setValue(w)
            self.heightSpinBoxSignalA.setValue(h)

        if roi is self.roi_B:
            # Populate fields with roi's new values
            self.originXSpinBoxSignalA.setValue(x)
            self.originYSpinBoxSignalA.setValue(y)
            self.widthSpinBoxSignalA.setValue(w)
            self.heightSpinBoxSignalA.setValue(h)
        self.updateParameters()


    def updateParameters(self):
        """Update Split parameter inputs and UI elements"""
        print('** Updating parameters')
        try:
            print('* trying')
            x_A, y_A = self.originXSpinBoxSignalA.value(), self.originYSpinBoxSignalA.value()
            w_A, h_A = self.widthSpinBoxSignalA.value(), self.heightSpinBoxSignalA.value()
            x_B, y_B = self.originXSpinBoxSignalB.value(), self.originYSpinBoxSignalB.value()
            w_B, h_B = self.widthSpinBoxSignalB.value(), self.heightSpinBoxSignalB.value()
            # r = int(roi_state['size'][0])
            # print("Updating roi params with: ", x, ' ', y, ' ', r)
            # Populate fields with passed values
            if self.lockDimensionsCheckBox.isChecked():
                self.widthSpinBoxSignalB.setValue(w_A)
                self.widthSpinBoxSignalB.setEnabled(False)
                self.heightSpinBoxSignalB.setValue(h_A)
                self.heightSpinBoxSignalB.setEnabled(False)
            else:
                # self.widthSpinBoxSignalB.setValue(w_B)
                self.widthSpinBoxSignalB.setEnabled(True)
                # self.heightSpinBoxSignalB.setValue(h_B)
                self.heightSpinBoxSignalB.setEnabled(True)
            self.updateROIs()
        except:
            exctype, exvalue = sys.exc_info()[:2]
            self.MainWindow.status_print('FAILED filter, ' + str(exctype) + ' : ' + str(exvalue))
            traceback.print_exc()

    def updateROIs(self):
        """Update Split ROIs based on parameters"""
        print('** Updating ROIs')
        try:
            x_A, y_A = self.originXSpinBoxSignalA.value(), self.originYSpinBoxSignalA.value()
            w_A, h_A = self.widthSpinBoxSignalA.value(), self.heightSpinBoxSignalA.value()
            x_B, y_B = self.originXSpinBoxSignalB.value(), self.originYSpinBoxSignalB.value()
            w_B, h_B = self.widthSpinBoxSignalB.value(), self.heightSpinBoxSignalB.value()
            self.roi_A.setPos([x_A, y_A])
            self.roi_A.setSize([w_A, h_A])
            self.roi_B.setPos([x_B, y_B])
            self.roi_B.setSize([w_B, h_B])
        except:
            exctype, exvalue = sys.exc_info()[:2]
            self.MainWindow.status_print('FAILED filter, ' + str(exctype) + ' : ' + str(exvalue))
            traceback.print_exc()

    def applySplit(self):
        """Applies the split, currently only for one horizontal split"""
        try:
            print('\n*** Applying Split')
            # self.MainWindow.status_print('Splitting video ...')
            # Find the width and height of the color image
            im_size = self.image_full.shape
            print('* Original image size ' + str(im_size))
            # width = int(im_size[0] / 2)
            # height = im_size[1]
            frames = im_size[2]

            width, height = self.roi_A.size()
            width, height = int(width), int(height)
            # Extract the two channels from the gray scale image
            # and merge the two channels into one color image
            im_color = np.zeros((width, height, frames, 2), dtype=np.uint16, order='F')
            for i in range(0, 2):
                im_color[:, :, :, i] = self.image_full[i * width:(i + 1) * width, 0:height, :]

            if self.alignCheckBox.isChecked():
                print('** Aligning stacks, assumes differences are translational with no rotation')
                im_color[..., 1] = align.align_stacks(im_color[..., 0], im_color[..., 1])
                print('** ... ')

            print('** Reshape/refill video_data, and update stack data')
            self.currentWindow.video_data = np.zeros((width, height, frames, 2), dtype=np.uint16, order='F')
            for i in range(0, 2):
                self.currentWindow.video_data[..., i] = im_color[..., i]
            self.currentWindow.addSignal()
            self.currentWindow.updateVideo()
            self.close()
        except Exception:
            exctype, exvalue = sys.exc_info()[:2]
            self.MainWindow.status_print('FAILED filter, ' + str(exctype) + ' : ' + str(exvalue))
            traceback.print_exc()


class WindowIsolate(QWidget, Ui_WidgetIsolate):
    """Customization for Ui_WidgetIsolate subwindow for an MDI"""

    # TODO REDO roi_preview to use updatePreviewPlot
    # TODO FIX crash when applying to two sources
    # TODO move *NEW* combobox items to the ends, rather than the beginnings

    def __init__(self, parent=None, w_list=None):
        # initialization of the superclass
        super(WindowIsolate, self).__init__(parent)
        print('Creating WidgetIsolate')
        self.windowList = w_list
        self.currentFileName = ''
        self.currentFilePath = ''
        self.windowDict = {}  # Dictionary with structure "window_name_short": "window"
        name_limit = 50
        for w in self.windowList:
            w_name = w.widget().objectName()
            w_name_short = '..' + w_name[-name_limit:] if len(w_name) > name_limit else w_name
            # Populate dictionary
            self.windowDict[w_name_short] = w.widget()
        self.currentWindow = None
        self.currentPlot = None
        self.currentROIs = []
        self.roi_preview = None
        self.condition_results = None
        # setup the GUI
        print('WidgetIsolate UI setup...')
        self.setupUi(self)
        # Setup preview plot in isolate subwindow
        # TODO remove border around preview, maybe switch to:
        #         self.rawImg = RawImageWidget(QWidget())
        w_preview = self.widgetPreview.addLayout(row=0, col=0)
        self.v_preview = w_preview.addViewBox(lockAspect=True)
        self.img_preview = pg.ImageItem()
        self.v_preview.addItem(self.img_preview)
        self.v_preview.disableAutoRange('xy')
        self.v_preview.autoRange()
        self.plot_preview = self.widgetPreviewPlot.addPlot()

        self.comboBoxSource.addItems(self.windowDict.keys())
        self.comboBoxSource.currentIndexChanged['int'].connect(self.selectionMadeSource)
        self.comboBoxROIs.currentIndexChanged['int'].connect(self.selectionMadeROI)

        self.buttonBox.button(QDialogButtonBox.RestoreDefaults).clicked.connect(self.loadDefaults)
        self.buttonBox.button(QDialogButtonBox.Apply).clicked.connect(self.applyROI)
        self.buttonBox.button(QDialogButtonBox.Discard).clicked.connect(self.discardROI)
        self.checkBoxPreview.stateChanged.connect(self.checkBoxChangedPreview)
        self.buttonBox.button(QDialogButtonBox.Apply).setEnabled(True)
        self.selectionMadeSource(0)

        print('WidgetIsolate ready')

    def closeEvent(self, event):
        """Reimplementation of QWidget.closeEvent

        Parameters
        ----------
        event : PySide2.QtGui.QCloseEvent
            Event when Qt receives a window close request for a top-level widget from the window system
        """
        for roi in self.currentWindow.ROIs:
            roi.setPen(color='54FF00')
        self.checkBoxPreview.setChecked(False)
        event.accept()

    def selectionMadeSource(self, i):
        """Slot for comboBoxSource.currentIndexChanged"""
        print('** selection made in a ', type(self))
        print('* Current Source: ', i, ', ', self.comboBoxSource.currentText())
        self.currentWindow = self.windowDict[self.comboBoxSource.currentText()]
        self.currentPlot = self.currentWindow.graphicsView.p1

        self.currentROIs = self.currentWindow.ROIs
        self.comboBoxROIs.clear()
        self.comboBoxROIs.addItem('*New*')
        for idx, roi in enumerate(self.currentROIs):
            self.comboBoxROIs.addItem(str(idx) + ': ' + str(roi.saveState()))
            print('Listing ROI #', idx, ': ', roi)

        print('* Window: ', str(self.currentWindow))
        print('* W x H: ', str(self.currentWindow.width), ' X ', str(self.currentWindow.height))
        print('* ROIs: ', str(self.currentROIs))
        self.loadDefaults()

    def selectionMadeROI(self, i):
        """Slot for comboBoxROIs.currentIndexChanged"""
        print('** selection made in a ', type(self))
        print('* Current ROI: #', i, ': ', self.comboBoxROIs.currentText())
        for roi in self.currentWindow.ROIs:
            roi.setPen(color='54FF00')
        index_current = self.comboBoxROIs.currentIndex()
        if index_current > 0:
            # An existing ROI has been selected
            # self.checkBoxPreview.setChecked(False)
            roi_current = self.currentWindow.ROIs[index_current - 1]
            print('* ROI #', index_current - 1, ': ', str(roi_current))
            roi_current.setPen(color='FF000A')
            # self.roi_preview = roi_current
            self.updateParameters(roi_current)
        else:
            # *NEW* has been selected
            print('* ROI NEW selected')
            self.loadDefaults()
            self.checkBoxPreview.setChecked(True)

    def loadDefaults(self):
        """Populate ROI parameter inputs with default values"""
        print('** Loading defaults')
        default_r = 15
        # Populate fields with default values
        self.originXLineEdit.setText(str(int(self.currentWindow.width / 2)))
        self.originYLineEdit.setText(str(int(self.currentWindow.height / 2)))
        self.radiusSpinBox.setValue(default_r)

    def updateParameters(self, roi):
        """Populate ROI parameter inputs with an existing ROI's parameters"""
        roi_state = roi.getState()
        x, y = str(int(roi_state['pos'].x())), str(int(roi_state['pos'].y()))
        r = int(roi_state['size'][0])
        # print("Updating roi params with: ", x, ' ', y, ' ', r)
        # Populate fields with passed values
        self.originXLineEdit.setText(x)
        self.originYLineEdit.setText(y)
        self.radiusSpinBox.setValue(r)

    def checkBoxChangedPreview(self):
        """Create/destroy preview ROI and read parameter entries"""
        print('\n*** checkBoxChangedPreview')
        if self.checkBoxPreview.isChecked():
            try:
                if not self.roi_preview:
                    # Get current ROI values
                    print('* checkBoxChangedPreview_1')
                    x, y = int(self.originXLineEdit.text()), int(self.originYLineEdit.text())
                    r = self.radiusSpinBox.value()
                    # Create preview ROI if it doesn't exist
                    print('* checkBoxChangedPreview_2')
                    self.roi_preview = pg.CircleROI([x, y], [r, r], pen=(2, 9), scaleSnap=True, translateSnap=True)
                    self.roi_preview.setPen(color='FF8700')
                    # Draw region on current tiff window's plot
                    print('* checkBoxChangedPreview_3')
                    self.currentPlot.addItem(self.roi_preview)
                    self.roi_preview.sigRegionChangeFinished.connect(self.updatePreviewImage)
                    self.roi_preview.sigRegionChangeFinished.connect(lambda: self.updateParameters(self.roi_preview))
                    # self.roi_preview.sigRegionChanged.connect(lambda: self.updateParameters(self.roi_preview))
                    # self.roi_preview.sigRegionChangeFinished.connect(self.updatePreviewPlot)

                    self.originXLineEdit.textEdited.connect(self.updatePreviewROI)
                    self.originYLineEdit.textEdited.connect(self.updatePreviewROI)
                    self.radiusSpinBox.valueChanged.connect(self.updatePreviewROI)
                    self.updatePreviewROI()
                    # self.updatePreviewPlot()
                    print('** Created preview ROI')
            except Exception:
                traceback.print_exc()
        else:
            # Remove preview ROI
            try:
                print('* checkBoxChangedPreview_remove')
                self.currentPlot.removeItem(self.roi_preview)
                self.roi_preview = None
                self.buttonBox.button(QDialogButtonBox.Apply).setEnabled(False)
                print('** Removed preview ROI')
            except Exception:
                traceback.print_exc()

    def updatePreviewROI(self):
        """Update ROI preview in Isolate subwindow"""
        print('\n*** updatePreviewROI')
        if self.roi_preview:
            # ROI Preview exists, update the params
            # Get current ROI values
            x, y = int(self.originXLineEdit.text()), int(self.originYLineEdit.text())
            r = self.radiusSpinBox.value()
            self.roi_preview.setPos((x, y))
            self.roi_preview.setSize(r)
            #
            # self.updatePreviewImage()
            print('** Updated ROI preview')
        else:
            print('** No ROI preview to update, clearing!')

    def updatePreviewImage(self):
        """Update ROI preview image in Isolate subwindow"""
        print('\n*** updatePreviewImage')
        if self.roi_preview:
            # Get current video frame data and preview ROI data
            data_frame = self.currentWindow.display_data[..., self.currentWindow.frame_current]
            data_preview = self.currentWindow.getRoiPreview(self.roi_preview)

            # self.roi_preview.setParentItem(img_preview)
            # Draw preview data in isolate subwindow
            self.img_preview.setImage(data_preview, levels=(0, data_frame.max()))
            self.v_preview.autoRange()
            self.buttonBox.button(QDialogButtonBox.Apply).setEnabled(True)
            print('** Set ROI preview image')
        else:
            self.v_preview.clear()
            print('** No ROI preview image to update, clearing!')

    def updatePreviewPlot(self):
        """Update ROI preview plot in Isolate subwindow"""
        print('\n*** updatePreviewPlot')
        if self.roi_preview:
            # Calculate conditioned ROI data across all frames
            print('* Calculating ROI mean')
            roi_data = self.currentWindow.getRoiStack(self.roi_preview)
            # Calculate normalized mean data
            roi_data_mean = np.zeros(len(roi_data))
            # roi_data_mean = np.zeros(self.currentWindow.frames)
            for idx, frame in enumerate(roi_data):
                roi_data_mean[idx] = np.nanmean(frame)
            roi_data_mean_norm = np.copy(roi_data_mean)
            norm_MIN = roi_data_mean_norm.min()
            norm_MAX = roi_data_mean_norm.max()
            roi_data_mean_norm = (roi_data_mean_norm - norm_MIN) / (norm_MAX - norm_MIN)
            # if 'Voltage' in self.analysis_preview['TYPE']:
            # roi_data_mean_norm = 1 - roi_data_mean_norm
            print('* ROI mean calculated')
            self.condition_results = roi_data_mean_norm
            # Plot conditioned signal
            self.plot_preview.plot(self.condition_results, clear=True)
            print('** Set ROI preview plot')
        else:
            self.plot_preview.clear()
            print('** No ROI preview plot to update, clearing!')

    def applyROI(self):
        """Add an ROI to a TIFF or applies changes to an existing ROI"""
        if not self.roi_preview:
            print('\n*** No roi_preview to add or edit with')
            return
        else:
            # Add or update the ROI
            if self.comboBoxROIs.currentIndex() is 0:
                # Add the preview ROI to the current TIFF window
                print('\n*** Applying *NEW* ROI ')
                self.currentWindow.addROI(roi=self.roi_preview)
            else:
                # Set state of the chosen ROI (current list index - 1, due to *NEW* at index 0)
                idx_roi = self.comboBoxROIs.currentIndex() - 1
                print('\n*** Changing ROI #' + str(idx_roi))
                roi_current = self.currentROIs[idx_roi]
                self.currentWindow.addROI(idx=idx_roi, roi=self.roi_preview)
                roi_current.setPen(color='54FF00')
            self.checkBoxPreview.setChecked(False)
            self.selectionMadeSource(0)

    def discardROI(self):
        """Remove an existing ROI from an open TIFF"""
        print('\n*** Discarding ROI')
        if self.comboBoxROIs.currentIndex() is 0:
            print('\n*** Cannot discard *NEW* ROI!')
        else:
            if len(self.currentROIs) < 1:
                print('\n*** No ROIs to discard!')
            else:
                print('** Removing ROI: ', self.comboBoxROIs.currentText())
                idx_roi = self.comboBoxROIs.currentIndex() - 1
                roi_current = self.currentROIs[idx_roi]

                self.currentWindow.removeROI(idx=idx_roi, roi=roi_current)
                self.checkBoxPreview.setChecked(False)
                self.selectionMadeSource(0)


class WindowAnalyze(QWidget, Ui_WidgetAnalyze):
    """Customization for Ui_WidgetAnalyze subwindow for an MDI"""

    # TODO clean up Apply and OK UI flow
    # TODO ADD export trace as .csv feature to Condition Tab

    def __init__(self, parent=None, w_list=None):
        # initialization of the superclass
        super(WindowAnalyze, self).__init__(parent)
        self.MainWindow = parent
        print('Creating WidgetAnalyze')
        self.windowList = w_list
        self.currentFileName = ''
        self.currentFilePath = ''
        self.windowDict = {}  # Dictionary with structure "window_name_short": "window"
        name_limit = 50
        for w in self.windowList:
            w_name = w.widget().objectName()
            w_name_short = '..' + w_name[-name_limit:] if len(w_name) > name_limit else w_name
            # Populate dictionary
            self.windowDict[w_name_short] = w.widget()
        self.currentWindow = None
        self.currentVideoPlot = None
        self.currentROIs = []
        self.currentSignals = []
        self.currentAnalysis = []
        self.roi_current = None
        self.signal_current = None
        self.analysis_preview = None
        self.frame_start, self.frame_end = None, None
        self.condition_results = None
        self.peak_results = None
        self.process_results = None

        # setup the GUI
        print('WidgetAnalyze UI setup...')
        self.setupUi(self)
        self.plot_preview = self.widgetPreview.addPlot()
        self.checkBoxTimeAll.stateChanged.connect(self.checkBoxChangedTimeAll)
        self.groupBoxFilter.toggled.connect(self.filterCheckBoxChanged)
        self.groupBoxDetrend.toggled.connect(self.detrendCheckBoxChanged)
        self.tabCondition.setEnabled(False)
        self.tabPeakDetect.setEnabled(False)
        self.tabProcess.setEnabled(False)
        self.buttonBoxAnalyze.button(QDialogButtonBox.Ok).setEnabled(False)

        self.comboBoxSource.addItems(self.windowDict.keys())
        self.comboBoxSource.currentIndexChanged['int'].connect(self.selectionMadeSource)
        self.comboBoxROIs.currentIndexChanged['int'].connect(self.selectionMadeROI)
        self.comboBoxSignal.currentIndexChanged['int'].connect(self.selectionMadeSignal)
        self.comboBoxAnalysis.currentIndexChanged['int'].connect(self.selectionMadeAnalysis)

        self.buttonBoxTimeSlice.button(QDialogButtonBox.Apply).clicked.connect(self.applyTimeSlice)
        self.buttonBoxCondition.button(QDialogButtonBox.Apply).clicked.connect(self.applyCondition)
        self.pushButtonExportTrace.clicked.connect(self.exportTrace)
        self.buttonBoxPeakDetect.button(QDialogButtonBox.Apply).clicked.connect(self.applyPeakDetect)
        self.buttonBoxProcess.button(QDialogButtonBox.Apply).clicked.connect(self.applyProcess)

        self.buttonBoxAnalyze.button(QDialogButtonBox.RestoreDefaults).clicked.connect(self.loadDefaults)
        self.buttonBoxAnalyze.button(QDialogButtonBox.Ok).clicked.connect(self.applyAnalysis)
        self.buttonBoxAnalyze.button(QDialogButtonBox.Discard).clicked.connect(self.discardAnalysis)
        self.progressBar.setValue(0)
        self.selectionMadeSource(0)

        self.startSpinBox.setMaximum(self.currentWindow.frames)
        self.endSpinBox.setMaximum(self.currentWindow.frames)
        self.endSpinBox.setValue(self.currentWindow.frames)
        self.checkBoxTimeAll.setChecked(True)

        # self.listWidgetOpenTiffs.addItems(self.windowListNames)
        print('WidgetAnalyze ready')

    def closeEvent(self, event):
        """Reimplementation of QWidget.closeEvent

        Parameters
        ----------
        event : PySide2.QtGui.QCloseEvent
            Event when Qt receives a window close request for a top-level widget from the window system
        """
        for roi in self.currentWindow.ROIs:
            roi.setPen(color='54FF00')
        event.accept()

    def selectionMadeSource(self, i):
        """Slot for comboBoxSource.currentIndexChanged"""
        print('\n*** selection #', i, ' made in a ', type(self))
        print('* Current Source: ', self.comboBoxSource.currentText())
        self.currentWindow = self.windowDict[self.comboBoxSource.currentText()]
        self.currentVideoPlot = self.currentWindow.graphicsView.p1

        self.comboBoxROIs.clear()
        self.currentROIs = self.currentWindow.ROIs
        for idx, roi in enumerate(self.currentROIs):
            self.comboBoxROIs.addItem(str(idx) + ': ' + str(roi.saveState()))
            print('Listing ROI #', idx, ': ', roi)

        self.comboBoxSignal.clear()
        self.currentSignals = self.currentWindow.Signal_widgets
        for idx, signal_w in enumerate(self.currentSignals):
            self.comboBoxSignal.addItem(str(idx) + ': ' + str(signal_w.comboBoxSignal.currentText()))
            print('Listing Signals #', idx, ': ', str(signal_w))

        self.comboBoxAnalysis.clear()
        self.currentAnalysis = self.currentWindow.Analysis
        self.comboBoxAnalysis.addItem('*New*')
        for idx, analysis in enumerate(self.currentAnalysis):
            analysis_display = '#' + str(idx) + ': ' + analysis['TYPE']
            self.comboBoxAnalysis.addItem(str(idx) + ': ' + analysis_display)
            print('Listing Analysis #', idx, ': ', analysis_display)

        print('* Window: ', str(self.currentWindow))
        print('* W x H: ', str(self.currentWindow.width), ' X ', str(self.currentWindow.height))
        print('* ROIs: ', str(self.currentROIs))
        print('* Signals: ', str(self.currentSignals))
        print('* Analysis: ', str(self.currentAnalysis))
        # self.loadDefaults()

    def selectionMadeROI(self, i):
        """Slot for comboBoxROIs.currentIndexChanged"""
        print('\n*** selection #', i, ' made in a ', type(self))
        print('** Current ROI: ', self.comboBoxROIs.currentText())
        for roi in self.currentWindow.ROIs:
            roi.setPen(color='54FF00')
        index_current = self.comboBoxROIs.currentIndex()
        # An existing ROI has been selected
        self.roi_current = self.currentWindow.ROIs[index_current]
        print('* ROI: ', str(self.roi_current))
        self.roi_current.setPen(color='FF000A')
        self.progressBar.setValue(20)

    def selectionMadeSignal(self, i):
        """Slot for comboBoxSignal.currentIndexChanged"""
        print('\n*** selection #', i, ' made in a ', type(self))
        print('** Current Signal: ', self.comboBoxSignal.currentText())
        index_current = self.comboBoxSignal.currentIndex()
        # An existing Signal has been selected
        self.signal_current = self.currentWindow.Signal_widgets[index_current]
        print('* Signal #', index_current, ': ', str(self.signal_current.comboBoxSignal.currentText()))

    def selectionMadeAnalysis(self, i):
        """Slot for comboBoxAnalysis.currentIndexChanged"""
        print('\n*** selection #', i, ' made in a ', type(self))
        print('** Current Analysis: ', self.comboBoxAnalysis.currentText())
        index_current = self.comboBoxAnalysis.currentIndex()
        if index_current > 0:
            # An existing Analysis has been selected
            self.analysis_preview = self.currentWindow.Analysis[index_current - 1]
            print('* Analysis #', index_current - 1, ': ', str(self.analysis_preview))
            self.updateParameters(self.analysis_preview)
        else:
            # *NEW* has been selected
            self.loadDefaults()

    def loadDefaults(self):
        """Populate Analysis parameter inputs with default values"""
        print('** Load defaults!')
        self.analysis_preview = self.currentWindow.analysis_default.copy()
        self.updateParameters(self.currentWindow.analysis_default)
        if self.tabProcess.isEnabled():
            self.tabProcess.setEnabled(False)
            self.buttonBoxAnalyze.button(QDialogButtonBox.Ok).setEnabled(False)
        if self.tabPeakDetect.isEnabled():
            self.tabPeakDetect.setEnabled(False)
        if self.tabCondition.isEnabled():
            self.tabCondition.setEnabled(False)
        self.plot_preview.clear()
        self.progressBar.setValue(20)
        self.tabWidgetAnalysisSteps.setCurrentWidget(self.tabTimeSlice)

    def updateParameters(self, analysis):
        """Populate Analysis parameter inputs with an existing Analysis's parameters"""
        print('** Updating Analysis parameters')
        roi = analysis['ROI']
        start, end = analysis['FRAMES'].split('-')
        analysis_type = analysis['TYPE']
        roi_calc = analysis['ROI_CALC']
        analysis_filter = analysis['FILTER']
        analysis_detrend = analysis['DETREND']
        peaks_thresh, peaks_lockout = analysis['PEAKS'].split(',')
        print("* using Analysis parameters: ", roi, ' ', analysis_type, ' ', roi_calc, ' ', analysis_filter, ' ',
              analysis_detrend, ' ', peaks_thresh, ',', peaks_lockout, ' ', process)

        # Populate fields with passed values
        self.startSpinBox.setValue(int(start))
        try:
            self.endSpinBox.setValue(int(end))
        except ValueError:
            # Use videos frame count if nothing passed
            self.endSpinBox.setValue(self.currentWindow.frames)

        self.signalTypeComboBox.setCurrentText(str(analysis_type))
        self.roiCalculationComboBox.setCurrentText(roi_calc)
        if pd.isna(analysis_filter):
            self.groupBoxFilter.setChecked(False)
        else:
            self.groupBoxFilter.setChecked(True)
            self.filterFreqSpinBox.setValue(int(analysis_filter))
        if pd.isna(analysis_detrend):
            self.groupBoxDetrend.setChecked(False)
        else:
            self.groupBoxDetrend.setChecked(True)
            self.detrendDegreeSpinBox.setValue(int(analysis_detrend))
        self.thresholdDoubleSpinBox.setValue(float(peaks_thresh))
        self.lockoutTimeSpinBox.setValue(int(peaks_lockout))
        # self.allResultsCheckBoxVm.setChecked(process == 'ALL')
        # self.allResultsCheckBoxCa.setChecked(process == 'ALL')

    def checkBoxChangedTimeAll(self):
        """Toggle use of all frames of a video for the current ROI"""
        print('** checkBoxChangedTimeAll')
        if self.checkBoxTimeAll.isChecked():
            self.startSpinBox.setValue(1)
            self.startSpinBox.setEnabled(False)
            self.endSpinBox.setValue(self.currentWindow.frames)
            self.endSpinBox.setEnabled(False)
            print('* UseAll checked')
        else:
            self.startSpinBox.setEnabled(True)
            self.endSpinBox.setEnabled(True)
            print('* UseAll unchecked')

    def filterCheckBoxChanged(self):
        """Toggle use of a low pass filter for the current conditioning"""
        if self.groupBoxFilter.isChecked():
            self.filterFreqSpinBox.setEnabled(True)
            print('\n*** Detrend checked')
        else:
            self.filterFreqSpinBox.setEnabled(False)
            print('\n*** Detrend unchecked')

    def detrendCheckBoxChanged(self):
        """Toggle use of a polynomial detrend for the current conditioning"""
        if self.groupBoxDetrend.isChecked():
            self.detrendDegreeSpinBox.setEnabled(True)
            print('\n*** Filter checked')
        else:
            self.detrendDegreeSpinBox.setEnabled(False)
            print('\n*** Filter unchecked')

    def applyTimeSlice(self):
        """Apply Time Slice tab selections"""
        try:
            print('\n*** Applying Time Slice, Start:', self.startSpinBox.text(),
                  ' End:', self.endSpinBox.text())
            # Set frame range of ROI, or None for all frames
            if not self.checkBoxTimeAll.isChecked():
                self.frame_start = int(self.startSpinBox.text())
                self.frame_end = int(self.endSpinBox.text())
                # Plot full length signal
                roi_data_full = self.currentWindow.getRoiStack(self.roi_current)
                # Calculate normalized mean data
                roi_data_full_mean = np.zeros(len(roi_data_full))
                for idx, frame in enumerate(roi_data_full):
                    roi_data_full_mean[idx] = np.nanmean(frame)
                roi_data_full_mean_norm = np.copy(roi_data_full_mean)
                norm_MIN = roi_data_full_mean_norm.min()
                norm_MAX = roi_data_full_mean_norm.max()
                roi_data_full_mean_norm = (roi_data_full_mean_norm - norm_MIN) / (norm_MAX - norm_MIN)
                self.plot_preview.plot(roi_data_full_mean_norm, pen=pg.mkPen(0.5), clear=True)
                print('* Full roi_data plotted')
            else:
                self.frame_start = 1
                self.frame_end = self.currentWindow.frames
                self.plot_preview.clear()

            self.analysis_preview['FRAMES'] = str(self.frame_start) + '-' + str(self.frame_start)
            print('* Time Slice start/end read')
            roi_data = self.currentWindow.getRoiStack(self.roi_current, stack_idx=self.comboBoxSignal.currentIndex(),
                                                      start_idx=self.frame_start - 1, end_idx=self.frame_end - 1)
            print('* Time Slice roi_data computed')
            # Calculate normalized mean data
            roi_data_mean = np.zeros(len(roi_data))
            for idx, frame in enumerate(roi_data):
                roi_data_mean[idx] = np.nanmean(frame)
            roi_data_mean_norm = np.copy(roi_data_mean)
            norm_MIN = roi_data_mean_norm.min()
            norm_MAX = roi_data_mean_norm.max()
            roi_data_mean_norm = (roi_data_mean_norm - norm_MIN) / (norm_MAX - norm_MIN)
            print('* ROI normalized mean calculated')
            # Plot ROI's time-sliced mean values
            sliced_results = roi_data_mean_norm
            # Plot conditioned signal
            x = np.arange(start=self.frame_start, stop=self.frame_end)
            self.plot_preview.plot(x=x, y=sliced_results)
            # self.plot_preview.plot(roi_data, clear=True)
            print('* Time Slice roi_data plotted')

            if self.tabProcess.isEnabled():
                self.tabProcess.setEnabled(False)
                self.buttonBoxAnalyze.button(QDialogButtonBox.Ok).setEnabled(False)
            self.tabCondition.setEnabled(True)
            self.tabWidgetAnalysisSteps.setCurrentWidget(self.tabCondition)
            self.progressBar.setValue(10)
        except Exception:
            traceback.print_exc()
        print('\n*** Finished Applying Time Slice')

    def applyCondition(self):
        """Apply Condition tab selections"""
        print('\n*** Applying Condition, Signal Type:', self.signalTypeComboBox.currentText(),
              ' ROI Calc.:', self.roiCalculationComboBox.currentText())
        self.progressBar.setValue(20)
        self.analysis_preview['ROI'] = str(self.comboBoxROIs.currentIndex())
        self.analysis_preview['TYPE'] = self.signalTypeComboBox.currentText()
        self.analysis_preview['ROI_CALC'] = self.roiCalculationComboBox.currentText()
        if self.groupBoxFilter.isChecked():
            self.analysis_preview['FILTER'] = str(self.filterFreqSpinBox.value())
        else:
            self.analysis_preview['FILTER'] = np.nan
        print('** analysis_preview: ', self.analysis_preview)

        # Calculate conditioned ROI data across all frames
        print('** ROI_CALC is ', self.analysis_preview['ROI_CALC'])
        if 'Mean' in self.analysis_preview['ROI_CALC']:
            print('* Calculating ROI mean')
            # Check for/use ROI's frame info
            # if self.analysis_preview['FRAMES']
            roi_data = self.currentWindow.getRoiStack(self.roi_current, stack_idx=self.comboBoxSignal.currentIndex(),
                                                      start_idx=self.frame_start, end_idx=self.frame_end)
            # Allocate space for mean data array
            roi_data_mean = np.zeros(len(roi_data))

            for idx, frame in enumerate(roi_data):
                roi_data_mean[idx] = np.nanmean(frame)
            if 'Voltage' in self.analysis_preview['TYPE']:
                # TODO Signal type should determine Process tab's results options (intensity signal, area, ...)
                roi_data_mean = 1 - roi_data_mean
            print('* ROI mean calculated')

            print('* Filtering ROI data')
            roi_data_mean_filter = roi_data_mean
            if self.groupBoxFilter.isChecked():
                fs = 1 / (self.currentWindow.dt / 1000)
                Wn = (self.filterFreqSpinBox.value() / (fs / 2))
                try:
                    [b, a] = sig.butter(5, Wn)
                    roi_data_mean_filter = sig.filtfilt(b, a, roi_data_mean_filter)
                except:
                    exctype, exvalue = sys.exc_info()[:2]
                    self.MainWindow.status_print('FAILED filter, ' + str(exctype) + ' : ' + str(exvalue))
                    traceback.print_exc()
            print('* ROI data Filtered')

            roi_data_mean_filter_detrend = np.copy(roi_data_mean_filter)
            if self.groupBoxDetrend.isChecked():
                print('* Detrending ROI data')
                # Polynomial fit and detrend
                # xp = np.linspace(0, len(roi_data_mean_filter), num=len(roi_data_mean_filter))
                # Fit a n'th degree polynomial to the data; minimises squared error in the order deg, deg-1, ... 0
                deg = self.detrendDegreeSpinBox.value()
                xp = np.arange(start=0, stop=len(roi_data_mean_filter))
                p = np.poly1d(np.polyfit(xp, roi_data_mean_filter, deg))
                roi_data_mean_filter_detrend = roi_data_mean_filter_detrend - p(xp)
                print('* ROI data Detrended')
                # roi_data_mean_filter_norm = sig.detrend(roi_data_mean_filter_norm)

            print('* Normalizing ROI data')
            roi_data_mean_filter_detrend_copy = np.copy(roi_data_mean_filter_detrend)
            norm_MIN = roi_data_mean_filter_detrend_copy.min()
            norm_MAX = roi_data_mean_filter_detrend_copy.max()
            roi_data_mean_filter_detrend_norm = (roi_data_mean_filter_detrend_copy - norm_MIN) / (norm_MAX - norm_MIN)
            print('* ROI data Normalized')

            self.condition_results = roi_data_mean_filter_detrend_norm
        else:
            print('* UNKNOWN ROI_CALC! : ', self.analysis_preview['ROI_CALC'])
        # Plot conditioned signal
        self.plot_preview.plot(self.condition_results, clear=True)
        # self.plot_preview.plot(xp, p(xp))

        self.tabPeakDetect.setEnabled(True)
        self.tabWidgetAnalysisSteps.setCurrentWidget(self.tabPeakDetect)
        self.buttonBoxAnalyze.button(QDialogButtonBox.Ok).setEnabled(False)
        self.progressBar.setValue(60)
        print('\n*** Finished Applying Condition')

    def exportTrace(self):
        """Export the trace before Peak Detection"""
        print('\n*** exportTrace!')
        try:
            if self.currentWindow.subject:
                file_name_list = [self.currentWindow.subject, self.currentWindow.video_name, '']
            else:
                file_name_list = [self.currentWindow.video_name, '']

            file_name_default = '_'.join(file_name_list)

            # File Dialog to generate filename
            export_file_name, _ = QFileDialog.getSaveFileName(self, 'Export results to .csv', file_name_default,
                                                              'Comma-separated values (*.csv)')
            print('* Exporting trace as: ', export_file_name)
            pd.DataFrame(self.condition_results).to_csv(export_file_name, na_rep='NaN', index=False)
            print('** Exported trace')
        except Exception:
            traceback.print_exc()

    def applyPeakDetect(self):
        """Apply Peak Detect tab selections"""
        print('\n*** Applying Peak Detect, Threshold:', self.thresholdDoubleSpinBox.value(),
              ' Lockout Time:', self.lockoutTimeSpinBox.value())
        self.progressBar.setValue(60)
        thresh = self.thresholdDoubleSpinBox.value()
        lockout = self.lockoutTimeSpinBox.value()
        param_peaks = str(thresh) + ',' + str(lockout)
        self.analysis_preview['PEAKS'] = param_peaks
        # Update windowtiff's default Thresh/Lockout with new values (unlikely to change)
        self.currentWindow.analysis_default['PEAKS'] = param_peaks
        print('** analysis_preview: ', self.analysis_preview)

        print('** PEAKS is ', self.analysis_preview['PEAKS'])
        try:
            self.peak_results = peak_detect.peak_detect(f=self.condition_results, thresh=thresh, LOT=lockout)
        except:
            exctype, exvalue = sys.exc_info()[:2]
            self.MainWindow.status_print('FAILED peak detection, ' + str(exctype) + ' : ' + str(exvalue))
            traceback.print_exc()

        [num_peaks, t0_locs, up_locs, peak_locs, base_locs, max_vel, peak_thresh] = self.peak_results
        print('** Detected ', num_peaks, ' peaks above ', peak_thresh)
        print('* max_vel: ', max_vel)

        # Redraw conditioned signal
        self.plot_preview.plot(self.condition_results, clear=True)
        # Mark t0_locs, yellow
        self.plot_preview.plot(t0_locs, self.condition_results[t0_locs], pen=None,
                               symbol='t1', symbolPen=None, symbolSize=10, symbolBrush=(250, 194, 5, 200))
        # Mark up_locs, orange
        self.plot_preview.plot(up_locs, self.condition_results[up_locs], pen=None,
                               symbol='t1', symbolPen=None, symbolSize=10, symbolBrush=(217, 83, 25, 200))
        # Mark peaks, red
        self.plot_preview.plot(peak_locs, self.condition_results[peak_locs], pen=None,
                               symbol='t1', symbolPen=None, symbolSize=10, symbolBrush=(255, 5, 5, 200))
        # Mark base_locs, grey
        self.plot_preview.plot(base_locs, self.condition_results[base_locs], pen=None,
                               symbol='t1', symbolPen=None, symbolSize=10, symbolBrush=(100, 100, 100, 200))
        print('* Peak results (signal, t0_locs, up_locs, peaks, base_locs) plotted')
        # # Mark upstroke
        # for slope in up_locs:
        #     vLine = pg.InfiniteLine(pos=slope, angle=90, movable=False, pen=[100, 255, 100, 80])
        #     self.plot_preview.addItem(vLine)
        #     # Mark the return to baseline
        #     for baseline in base_locs:
        #         if baseline > slope:
        #             vLine = pg.InfiniteLine(pos=baseline, angle=90, movable=False, pen=[100, 255, 100, 80])
        #             self.plot_preview.addItem(vLine)
        #             break
        self.plot_preview.setLabel('left', "Norm. Fluorescence")
        # self.plot_preview.setLabel('bottom', "Time", units='frames')
        # self.plot_preview.getAxis('bottom').enableAutoSIPrefix(enable=False)

        self.tabProcess.setEnabled(True)
        self.buttonBoxAnalyze.button(QDialogButtonBox.Ok).setEnabled(False)
        self.progressBar.setValue(80)
        self.tabWidgetAnalysisSteps.setCurrentWidget(self.tabProcess)
        print('\n*** Finished Applying Peak Detect')

    def applyProcess(self):
        """Apply Process tab selections"""
        # TODO Change datatable to mirror Morgan's Sleeping Bear excel sheet
        print('\n*** Applying Process, All Results')
        self.analysis_preview['RESULTS'] = None
        self.progressBar.setValue(80)
        [num_peaks, t0_locs, up_locs, peak_locs, base_locs, max_vel, peak_thresh] = self.peak_results
        print('** Processing ', num_peaks, ' peaks above ', peak_thresh)
        print('** analysis_preview: ', self.analysis_preview)
        print('** PROCESS is gone, I am the captain now')

        per_base = 80   # XX% for CaDXX/APDXX
        F0 = np.nanmean((self.condition_results[base_locs[1]:t0_locs[0]]))
        # for idx in num_peaks:
        #     f0[idx] = np.nanmean((self.condition_results[base_locs[idx-1]:t0_locs[idx-1]]))
        if 'Voltage' in self.analysis_preview['TYPE']:
            probe = 1
        else:
            probe = 0
        try:
            self.process_results = process.process(self.condition_results, self.currentWindow.dt,
                                                   t0_locs, up_locs, peak_locs, base_locs, max_vel, per_base, F0, probe)

            self.analysis_preview['RESULTS'] = self.process_results
            print('* Process results calculated')

            # TODO FIX rows showing sums of CLs, other values also weird
            table_model = PandasModel(self.process_results)
            self.processTableView.setModel(table_model)
            print('* Results table populated')

            self.buttonBoxAnalyze.button(QDialogButtonBox.Ok).setEnabled(True)
            self.progressBar.setValue(100)
            print('\n*** Finished Applying Process')
        except:
            exctype, exvalue = sys.exc_info()[:2]
            self.MainWindow.status_print('FAILED processing, ' + str(exctype) + ' : ' + str(exvalue))
            traceback.print_exc()

    def applyAnalysis(self):
        """Add an Analysis to a TIFF or applies changes to an existing Analysis"""
        print('\n*** Applying Analysis')
        if not self.analysis_preview:
            print('** No analysis_preview to add or edit with')
        else:
            if self.comboBoxAnalysis.currentIndex() is 0:
                print('** Applying *NEW* Analysis')
                # self.currentWindow.addAnalysis(self.currentWindow.analysis_default)
                self.currentWindow.addAnalysis(analysis=self.analysis_preview)
            else:
                # Set state of the chosen Analysis (current list index - 1, due to *NEW* at index 0)
                idx_analysis = self.comboBoxAnalysis.currentIndex() - 1
                print('** Changing Analysis #' + str(idx_analysis))
                self.currentWindow.addAnalysis(idx=idx_analysis, analysis=self.analysis_preview)

            if self.tabProcess.isEnabled():
                self.tabProcess.setEnabled(False)
                self.buttonBoxAnalyze.button(QDialogButtonBox.Ok).setEnabled(False)
            if self.tabPeakDetect.isEnabled():
                self.tabPeakDetect.setEnabled(False)
            self.progressBar.setValue(20)
            self.tabWidgetAnalysisSteps.setCurrentWidget(self.tabCondition)
            self.selectionMadeSource(0)
        print('\n*** Apply Analysis done')

    def discardAnalysis(self):
        """Remove an existing Analysis from a TIFF"""
        print('\n*** Discarding Analysis')
        if self.comboBoxAnalysis.currentIndex() is 0:
            print('** Cannot discard *NEW* Analysis!')
        else:
            if len(self.currentAnalysis) < 1:
                print('** No Analysis to discard!')
            else:
                print('** Removing Analysis: ', self.comboBoxAnalysis.currentText())
                idx_analysis = self.comboBoxAnalysis.currentIndex() - 1
                analysis_current = self.currentAnalysis[idx_analysis]

                self.currentWindow.removeAnalysis(idx=idx_analysis, analysis=analysis_current)

                if self.tabProcess.isEnabled():
                    self.tabProcess.setEnabled(False)
                    self.buttonBoxAnalyze.button(QDialogButtonBox.Ok).setEnabled(False)
                if self.tabPeakDetect.isEnabled():
                    self.tabPeakDetect.setEnabled(False)
                self.progressBar.setValue(20)
                self.tabWidgetAnalysisSteps.setCurrentWidget(self.tabCondition)
                self.selectionMadeSource(0)
        print('\n*** Discard Analysis done')


class WindowExport(QWidget, Ui_WidgetExport):
    """Customization for Ui_WidgetExportCopyPaste subwindow for an MDI"""

    def __init__(self, parent=None, w_list=None):
        # initialization of the superclass
        super(WindowExport, self).__init__(parent)
        print('Creating WidgetCopyPaste')
        self.windowList = w_list
        self.currentFileName = ''
        self.currentFilePath = ''
        self.windowDict = {}  # Dictionary with structure "window_name_short": "window"
        name_limit = 50
        for w in self.windowList:
            w_name = w.widget().objectName()
            w_name_short = '..' + w_name[-name_limit:] if len(w_name) > name_limit else w_name
            # Populate dictionary
            self.windowDict[w_name_short] = w.widget()
        self.currentWindow = None
        self.currentAnalysis = None
        self.currentAnalysis_copy = None
        self.currentROI = None
        self.currentResults = None
        self.finalResults = None
        self.clip = QApplication.clipboard()
        # setup the GUI
        print('WidgetCopyPaste UI setup...')
        self.setupUi(self)
        self.comboBoxSource.addItems(self.windowDict.keys())
        self.comboBoxSource.currentIndexChanged['int'].connect(self.selectionMadeSource)
        self.comboBoxAnalysis.currentIndexChanged['int'].connect(self.selectionMadeAnalysis)

        self.radioButtonIndividual.toggled.connect(self.loadResults)
        self.radioButtonIndividual.setChecked(True)
        self.radioButtonMean.toggled.connect(self.loadResults)
        self.checkBoxSD.toggled.connect(self.loadResults)

        self.checkBoxProperties.setChecked(False)
        self.checkBoxProperties.stateChanged.connect(self.loadResults)
        self.checkBoxAPDs.setChecked(True)
        self.checkBoxAPDs.stateChanged.connect(self.loadResults)
        self.checkBoxOther.setChecked(False)
        self.checkBoxOther.stateChanged.connect(self.loadResults)
        self.checkBoxParameters.setChecked(False)
        self.checkBoxParameters.stateChanged.connect(self.loadResults)

        self.pushButtonTrace.clicked.connect(self.copyResults)
        self.pushButtonResults.clicked.connect(self.exportResults)
        self.selectionMadeSource(0)
        print('WidgetCopyPaste ready')

    def selectionMadeSource(self, i):
        """Slot for comboBoxSource.currentIndexChanged"""
        print('** selection made in a ', type(self))
        print('* Current Source: ', i, ', ', self.comboBoxSource.currentText())
        self.currentWindow = self.windowDict[self.comboBoxSource.currentText()]

        self.comboBoxAnalysis.clear()
        for idx, analysis in enumerate(self.currentWindow.Analysis):
            roi, results_type = analysis['ROI'], analysis['TYPE']
            analysis_display = '#' + str(idx) + ': ' + results_type
            self.comboBoxAnalysis.addItem(analysis_display)
            print('Listing Analysis #', idx, ': ', analysis_display)

        print('*Window: ', str(self.currentWindow))
        print('*W x H: ', str(self.currentWindow.width), ' X ',
              str(self.currentWindow.height))

    def selectionMadeAnalysis(self, i):
        """Slot for comboBoxAnalysis.currentIndexChanged"""
        print('\n*** selection #', i, ' made in a ', type(self))
        print('** Current Analysis: ', self.comboBoxAnalysis.currentText())
        index_current = self.comboBoxAnalysis.currentIndex()
        self.currentAnalysis = self.currentWindow.Analysis[index_current]
        self.updateResults(self.currentAnalysis)
        self.radioButtonIndividual.setChecked(True)
        self.loadResults()

    def updateParameters(self):
        """Update Results parameters"""
        print('** Updating Results parameters')
        # try:
        #     if self.checkBoxAPDs.isChecked():
        #
        #     elif self.checkBoxPeriods.isChecked():
        #     else:
        #         if self.radioButtonAllResults.isChecked():
        #             self.checkBoxAPDs.setChecked(False)
        #             self.checkBoxPeriods.setChecked(False)
        #     self.loadResults()
        # except Exception:
        #     traceback.print_exc()

    def updateResults(self, analysis):
        """Update current Analysis and Results"""
        print('\n*** updateResults!')
        self.currentAnalysis_copy = analysis.copy()
        # print('* Old Analysis dict: ', self.currentAnalysis_copy)
        self.currentResults = self.currentAnalysis_copy.pop('RESULTS', None)
        print('** Removed RESULTS : ', self.currentResults)
        print('** New Analysis dict: ', self.currentAnalysis_copy)
        self.currentROI = self.currentAnalysis_copy['ROI']

    def loadResults(self):
        """Populate Results table with the current Analysis' results"""
        print('\n*** loadResults!')
        self.updateResults(self.currentAnalysis)

        # print('** currentResults:' + str(self.currentResults))
        if self.currentResults is None:
            print('\n*** No results yet!')
        else:
            print('** Found results')
            try:
                tempResults = pd.DataFrame()
                tempResultsProps = pd.DataFrame()
                tempResultsAPD = pd.DataFrame()
                tempResultsOther = pd.DataFrame()
                tempResultsParams = pd.DataFrame()

                # Filter based on desired values
                if self.checkBoxAPDs.isChecked():
                    print('* Using APDs')
                    # tempResultsAPD = self.currentResults.iloc[:, [0, 4, 5, 6, 7, 8]]
                    tempResultsAPD = self.currentResults.reindex(columns=['CL', 'APD30', 'APD80', 'APD90',
                                                                          'APD30/80', 'Vmax', 'TauFall'])
                if self.checkBoxOther.isChecked():
                    print('* Using all other data')
                    df = self.currentResults.iloc[:, 9:]
                    # Reindex columns into desired order
                    # tempResultsOther = df.reindex(columns=['mean', 0, 1, 2, 3, 4])
                    tempResultsOther = self.currentResults.reindex(columns=['ActTime', 'RiseTime', 'TimeToPeak',
                                                                            'Tri'])

                if not self.checkBoxOther.isChecked() and not self.checkBoxAPDs.isChecked():
                    print('* No results columns chosen!')
                tempResults = pd.concat([tempResultsAPD, tempResultsOther], axis=1)

                # Calculate means and SDs, if needed
                if self.radioButtonMean.isChecked():
                    print('* Using Mean results')
                    mean = tempResults.mean(axis=0)
                    mean = mean.to_frame().transpose()
                    mean_SD = pd.Series()
                    mean_combo = pd.Series()
                    self.checkBoxSD.setEnabled(True)
                    if self.checkBoxSD.isChecked():
                        print('* Using SD results')
                        mean_SD = tempResults.std(axis=0)
                        mean_SD_index = [s + '_SD' for s in mean_SD.index]
                        # mean_SD.index = mean_SD_index
                        # Interleave lists of means and SDs
                        # TODO change col interleave to a new row for SDs
                        mean_combo = mean.append(mean_SD, ignore_index=True)

                        # mean_combo_list = [np.nan] * (2 * len(mean))
                        # mean_combo_index = [np.nan] * (2 * len(mean))
                        # mean_combo_list[::2] = mean
                        # mean_combo_index[::2] = mean_SD.index
                        # mean_combo_list[1::2] = mean_SD
                        # mean_combo_index[1::2] = mean_SD_index
                        # mean_combo = pd.Series(mean_combo_list)
                        # mean_combo.index = mean_combo_index
                        # mean_combo = pd.Series([val for pair in zip(mean, mean_SD) for val in pair])
                    else:
                        mean_combo = mean
                    # tempResults.loc[0] = mean_combo
                    # tempResults = mean_combo.to_frame().transpose()
                    tempResults = mean_combo
                else:
                    print('* Using Individual results')
                    self.checkBoxSD.setEnabled(False)

                # Check if video Properties are needed
                if self.checkBoxProperties.isChecked():
                    print('* Using Properties')
                    # tempResultsProps = self.currentResults[['']]
                    tempResultsProps = pd.DataFrame(np.zeros(shape=(len(tempResults.index), 3)),
                                                    columns=['Subject', 'File', 'ROI#'])
                    tempResultsProps.loc[:, ['Subject']] = self.currentWindow.subject
                    tempResultsProps.loc[:, ['File']] = self.currentWindow.video_name
                    tempResultsProps.loc[:, ['ROI#']] = self.currentAnalysis_copy['ROI']
                tempResults = pd.concat([tempResultsProps, tempResults], axis=1)

                # Check if analysis Paramaters are needed
                if self.checkBoxParameters.isChecked():
                    print('* Using Parameters')
                    tempResultsParams = pd.DataFrame(np.zeros(shape=(len(tempResults.index), 6)),
                                                     columns=['ROI (X,Y)', 'ROI Size',
                                                              'Type', 'Calculation', 'Filter (Hz)',
                                                              'Peaks (Threshold, Lockout)'])

                    params_ROI = self.currentWindow.ROIs[int(self.currentROI)].getState()
                    x, y = str(int(params_ROI['pos'].x())), str(int(params_ROI['pos'].y()))
                    position = x + ',' + y
                    size = int(params_ROI['size'][0])

                    params_Analysis = self.currentAnalysis_copy
                    print('** Parameters:')
                    print('* ROI: ', params_ROI)
                    print('* Analysis: ', params_Analysis)

                    tempResultsParams.loc[:, ['ROI (X,Y)']] = position
                    tempResultsParams.loc[:, ['ROI Size']] = size
                    tempResultsParams.loc[:, ['Type']] = params_Analysis['TYPE']
                    tempResultsParams.loc[:, ['Calculation']] = params_Analysis['ROI_CALC']
                    tempResultsParams.loc[:, ['Filter (Hz)']] = params_Analysis['FILTER']
                    tempResultsParams.loc[:, ['Peaks (Threshold, Lockout)']] = params_Analysis['PEAKS']
                    # tempResultsParams.loc[:, ['ROI']] = 828
                    # tempResultsParams.loc[:, ['Analysis']] = 828
                tempResults = pd.concat([tempResults, tempResultsParams], axis=1)

                # Finalize results table
                self.finalResults = tempResults
                self.tableWidgetResults.setColumnCount(len(self.finalResults.columns))
                self.tableWidgetResults.setRowCount(len(self.finalResults.index))

                for i in range(len(self.finalResults.index)):
                    for j in range(len(self.finalResults.columns)):
                        dataDataFrame = self.finalResults.iat[i, j]
                        try:
                            # Round all float results to 5 significant digits, due to dt limit
                            float(dataDataFrame)
                            dataTable = str("{0:.5g}".format(dataDataFrame))
                        except ValueError:
                            # Not a float, no need to limit digits
                            dataTable = dataDataFrame
                        self.tableWidgetResults.setItem(i, j, QTableWidgetItem(dataTable))
                print('* Results table populated by results dataframe')
                self.tableWidgetResults.setHorizontalHeaderLabels(self.finalResults.columns)
                self.tableWidgetResults.resizeRowsToContents()
                self.tableWidgetResults.resizeColumnsToContents()
            except Exception:
                traceback.print_exc()

            print('** Results loaded!')

    def copyResults(self):
        print('\n*** copyResults!')
        try:
            print('** copy...')
            selected = self.tableWidgetResults.selectedRanges()
            # s = '\t' + "\t".join([str(self.tableWidgetResults.horizontalHeaderItem(i).text()) for i in
            #                       range(selected[0].leftColumn(), selected[0].rightColumn())])
            s = "\t".join([str(self.tableWidgetResults.horizontalHeaderItem(i).text()) for i in
                           range(selected[0].leftColumn(), selected[0].rightColumn())])
            s = s + '\n'
            for r in range(selected[0].topRow(), selected[0].bottomRow()):
                # s += self.tableWidgetResults.verticalHeaderItem(r).text() + '\t'
                # s += str(self.tableWidgetResults.verticalHeaderItem(r).text()) + '\t'
                for c in range(selected[0].leftColumn(), selected[0].rightColumn()):
                    try:
                        print('** try: s += str(self.table.item(r, c).text()) + "\t"')
                        s += str(self.tableWidgetResults.item(r, c).text()) + "\t"
                    except AttributeError:
                        s += "\t"
                s = s[:-1] + "\n"  # eliminate last '\t'
            self.clip.setText(s)
        except Exception:
            traceback.print_exc()

    def exportTrace(self):
        """Export the trace from the current Analysis"""
        print('\n*** exportTrace!')
        self.updateResults(self.currentAnalysis)

        if self.currentResults is None:
            print('\n*** No results yet!')
        else:
            print('** Found results')
            try:
                tempResults = pd.DataFrame()
            except Exception:
                traceback.print_exc()

    def exportResults(self):
        """Export the results from the current Analysis"""
        print('\n*** exportResults!')
        try:
            if self.currentWindow.subject:
                file_name_list = [self.currentWindow.subject, self.currentWindow.video_name, '']
            else:
                file_name_list = [self.currentWindow.video_name, '']

            file_name_default = '_'.join(file_name_list)

            # File Dialog to generate filename
            export_file_name, _ = QFileDialog.getSaveFileName(self, 'Export results to .csv', file_name_default,
                                                              'Comma-separated values (*.csv)')
            print('* Exporting results as: ', export_file_name)
            self.finalResults.to_csv(export_file_name, na_rep='NaN', index=False)
            print('** Exported results as')
        except Exception:
            traceback.print_exc()
        # selected = self.tableWidgetResults.selectedRanges()
        # # s = '\t' + "\t".join([str(self.tableWidgetResults.horizontalHeaderItem(i).text()) for i in
        # #                       range(selected[0].leftColumn(), selected[0].rightColumn())])
        # s = "\t".join([str(self.tableWidgetResults.horizontalHeaderItem(i).text()) for i in
        #                range(selected[0].leftColumn(), selected[0].rightColumn())])
        # s = s + '\n'
        # for r in range(selected[0].topRow(), selected[0].bottomRow()):
        #     # s += self.tableWidgetResults.verticalHeaderItem(r).text() + '\t'
        #     # s += str(self.tableWidgetResults.verticalHeaderItem(r).text()) + '\t'
        #     for c in range(selected[0].leftColumn(), selected[0].rightColumn()):
        #         try:
        #             print('** try: s += str(self.table.item(r, c).text()) + "\t"')
        #             s += str(self.tableWidgetResults.item(r, c).text()) + "\t"
        #         except AttributeError:
        #             s += "\t"
        #     s = s[:-1] + "\n"  # eliminate last '\t'
        # self.clip.setText(s)


class PandasModel(QtCore.QAbstractTableModel):
    """
    Class to populate a table view with a pandas dataframe
    """

    def __init__(self, data, parent=None):
        QtCore.QAbstractTableModel.__init__(self, parent)
        self._data = data

    def rowCount(self, parent=None, **kwargs):
        return self._data.shape[0]

    def columnCount(self, parent=None, **kwargs):
        return self._data.shape[1]

    def data(self, index, role=QtCore.Qt.DisplayRole):
        if index.isValid():
            if role == QtCore.Qt.DisplayRole:
                return str(self._data.iloc[index.row(), index.column()])
        return None

    def headerData(self, col, orientation, role=None):
        if orientation == QtCore.Qt.Horizontal and role == QtCore.Qt.DisplayRole:
            return self._data.columns[col]
        return None


if __name__ == '__main__':
    # create the GUI application
    app = QApplication(sys.argv)
    # instantiate the main window
    dmw = MDIWindow()
    # show it
    dmw.show()
    # start the Qt main loop execution, exiting from this script
    # with the same return code as the Qt application
    sys.exit(app.exec_())
